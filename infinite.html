<html><head><title>Sweeper Inifite</title><meta name="copyright" content="Copyright Lyall Ward 2024"><script>
class Point {x; y; constructor(e) {this.x=e.offsetX;this.y=e.offsetY;}}
class Coord {
 x; y;
 constructor(e) {
  this.x=Math.floor((e.offsetX-View.left)/View.size);
  this.y=Math.floor((e.offsetY-View.right)/View.size);}
 Same(e) {return (this.x==e.x) && (this.y==e.y);} }
class Image {
 canvas; context;
 constructor(w, h, c = undefined) {
  this.canvas = (c==undefined)?document.createElement('canvas'):c;
  this.canvas.setAttribute("width", w);
  this.canvas.setAttribute("height", h);
  this.context = this.canvas.getContext("2d"); } }
class Squares {
 static #image = Object.freeze({ 0:0, 1:1, 2:2, 3:3, 4:4, 5:5, 6:6, 7:7, 8:8, mine:9, explosion:10, unknown:11, flag:12, error:13, question:14, danger:15, min:16, max:17, demined:18 })
 static size = 0x200;
 static #step = 0x20;
 static #images = [];
 static #font = [ // 18 characters of a 16 by 16 character font for the board playfield
  [ 0,  0, [ 0xFFFF, 0x8000, 0x8000, 0x8000,  0x8000, 0x8000, 0x8000, 0x8000,  0x8000, 0x8000, 0x8000, 0x8000,  0x8000, 0x8000, 0x8000, 0x8000 ], "#808080"],  // 0
  [ 1,  0, [ 0x0000, 0x0000, 0x0000, 0x00C0,  0x01C0, 0x03C0, 0x07C0, 0x01C0,  0x01C0, 0x01C0, 0x01C0, 0x07F0,  0x07F0, 0x0000, 0x0000, 0x0000 ], "#0000FF"],  // 1
  [ 2,  0, [ 0x0000, 0x0000, 0x0000, 0x0FF0,  0x1FF8, 0x1C38, 0x0038, 0x00F0,  0x03E0, 0x0F80, 0x1E00, 0x1FF8,  0x1FF8, 0x0000, 0x0000, 0x0000 ], "#008000"],  // 2
  [ 3,  0, [ 0x0000, 0x0000, 0x0000, 0x1FF0,  0x1FF8, 0x0038, 0x0038, 0x03F0,  0x03F0, 0x0038, 0x0038, 0x1FF8,  0x1FF0, 0x0000, 0x0000, 0x0000 ], "#FF0000"],  // 3
  [ 4,  0, [ 0x0000, 0x0000, 0x0000, 0x0770,  0x0770, 0x0E70, 0x0E70, 0x1FF8,  0x1FF8, 0x0070, 0x0070, 0x0070,  0x0070, 0x0000, 0x0000, 0x0000 ], "#000080"],  // 4
  [ 5,  0, [ 0x0000, 0x0000, 0x0000, 0x1FF8,  0x1FF8, 0x1C00, 0x1C00, 0x1FF0,  0x1FF8, 0x0038, 0x0038, 0x1FF8,  0x1FF0, 0x0000, 0x0000, 0x0000 ], "#800000"],  // 5
  [ 6,  0, [ 0x0000, 0x0000, 0x0000, 0x0FF0,  0x1FF0, 0x1C00, 0x1C00, 0x1FF0,  0x1FF8, 0x1C38, 0x1C38, 0x1FF8,  0x0FF0, 0x0000, 0x0000, 0x0000 ], "#008080"],  // 6
  [ 7,  0, [ 0x0000, 0x0000, 0x0000, 0x1FF8,  0x1FF8, 0x0078, 0x00F0, 0x01E0,  0x01C0, 0x03C0, 0x0380, 0x0380,  0x0380, 0x0000, 0x0000, 0x0000 ], "#000000"],  // 7
  [ 8,  0, [ 0x0000, 0x0000, 0x0000, 0x0FF0,  0x1FF8, 0x1C38, 0x1C38, 0x0FF0,  0x0FF0, 0x1C38, 0x1C38, 0x1FF8,  0x0FF0, 0x0000, 0x0000, 0x0000 ], "#808080"],  // 8
  [ 9,  0, [ 0x0000, 0x0000, 0x0080, 0x0080,  0x0BE8, 0x07F0, 0x0FF8, 0x0FF8,  0x3FFE, 0x0FF8, 0x0FF8, 0x07F0,  0x0BE8, 0x0080, 0x0080, 0x0000 ], "#000000"],  //mine
  [ 9,  9, [ 0x0000, 0x0000, 0x0000, 0x0000,  0x0000, 0x0000, 0x0300, 0x0300,  0x0000, 0x0000, 0x0000, 0x0000,  0x0000, 0x0000, 0x0000, 0x0000 ], "#FFFFFF"],  //dot
  [10,  9, [ 0x0000, 0x7FFF, 0x7F7F, 0x7F7F,  0x7417, 0x780F, 0x7007, 0x7007,  0x4001, 0x7007, 0x7007, 0x780F,  0x7417, 0x7F7F, 0x7F7F, 0x7FFF ], "#FF0000"],  //explosion
  [11, 11, [ 0xFFFE, 0xFFFC, 0xC000, 0xC000,  0xC000, 0xC000, 0xC000, 0xC000,  0xC000, 0xC000, 0xC000, 0xC000,  0xC000, 0xC000, 0x8000, 0x0000 ], "#FFFFFF"],  //light
  [11, 11, [ 0x0000, 0x0001, 0x0003, 0x0003,  0x0003, 0x0003, 0x0003, 0x0003,  0x0003, 0x0003, 0x0003, 0x0003,  0x0003, 0x0003, 0x3FFF, 0x7FFF ], "#808080"],  //shadow
  [12, 11, [ 0x0000, 0x0000, 0x0000, 0x0180,  0x0780, 0x0F80, 0x0780, 0x0180,  0x0000, 0x0000, 0x0000, 0x0000,  0x0000, 0x0000, 0x0000, 0x0000 ], "#FF0000"],  //flag
  [12, 12, [ 0x0000, 0x0000, 0x0000, 0x0000,  0x0000, 0x0000, 0x0000, 0x0000,  0x0080, 0x0080, 0x03C0, 0x0FF0,  0x0FF0, 0x0000, 0x0000, 0x0000 ], "#000000"],  //post
  [13,  9, [ 0x0000, 0x0000, 0x2002, 0x3006,  0x180C, 0x0C18, 0x0630, 0x0360,  0x01C0, 0x0360, 0x0630, 0x0C18,  0x180C, 0x3006, 0x2002, 0x0000 ], "#FF0000"],  //cross
  [14, 11, [ 0x0000, 0x0000, 0x0000, 0x03C0,  0x0660, 0x0660, 0x0060, 0x00C0,  0x0180, 0x0180, 0x0000, 0x0180,  0x0180, 0x0000, 0x0000, 0x0000 ], "#000000"],  //?
  [15,  0, [ 0x0000, 0x0000, 0x0000, 0x0000,  0x01E0, 0x0330, 0x0330, 0x0030,  0x0060, 0x00C0, 0x00C0, 0x0000,  0x00C0, 0x00C0, 0x0000, 0x0000 ], "#000000"],  //?
  [16, 16, [ 0x3FFF, 0x0001, 0xFFFD, 0x8005,  0x8005, 0x8005, 0x8005, 0x8005,  0x8005, 0x8005, 0x8005, 0x8005,  0x8005, 0x8005, 0x8004, 0xFFFC ], "#FFFFFF"],  //min
  [17, 17, [ 0xFFFF, 0x8001, 0x8001, 0x8001,  0x8001, 0x8001, 0x8001, 0x8001,  0x8001, 0x8001, 0x8001, 0x8001,  0x8001, 0x8001, 0x8001, 0xFFFF ], "#FFFFFF"],  //max
  [18, 11, [ 0x0000, 0x0000, 0x0000, 0x0180,  0x0780, 0x0F80, 0x0780, 0x0180,  0x0000, 0x0000, 0x0000, 0x0000,  0x0000, 0x0000, 0x0000, 0x0000 ], "#FFC000"],  //flag
  [18, 18, [ 0x0000, 0x0000, 0x0000, 0x0000,  0x0000, 0x0000, 0x0000, 0x0000,  0x0080, 0x0080, 0x03C0, 0x0FF0,  0x0FF0, 0x0000, 0x0000, 0x0000 ], "#000000"],  //cleared
 ];
 static #Blank(c) { 
  c.fillStyle='#C0C0C0'; 
  c.fillRect(0,0,Squares.size,Squares.size);
 }
 static #DrawFont(f) {
  var c = Squares.#images[f[0]].context;
  c.drawImage(Squares.#images[f[1]].canvas,0,0);
  c.fillStyle=f[3];
  for (let i = 0; i < f[2].length; i++) {
   var pixels = f[2][i];
   var y = i * Squares.#step;
   for (let x = 0; x <= Squares.size; x += Squares.#step, pixels <<= 1) {if ((pixels & 0x8000) > 0) { c.fillRect(x, y, Squares.#step, Squares.#step); }}}}
 static Image(c) { 
  var i = Squares.#image.unknown;
  if (c.cleared) {
   if (c.proximity >= 0) i = c.proximity;
   if (c.death) i = Squares.#image.explosion;
  } else {
   if (c.flagged) i = Squares.#image.flag;
   if (c.demined) i = Squares.#image.demined; }
  return Squares.#images[i].canvas;
 } 
 static {
  for (let i = 0; i < 19; i++) { Squares.#images.push(new Image(Squares.size, Squares.size)); }
  Squares.#Blank(Squares.#images[0].context);
  Squares.#Blank(Squares.#images[11].context);  
  for (let a = 0; a < Squares.#font.length; a++) { Squares.#DrawFont(Squares.#font[a]); } }
}
class Cell {
 static #high = 0.26;
 static #density = 0.25;
 static #low = 0.24;
 static #bias = Cell.#density;
 static #mines = 0;
 static #total = 0;
 mine = false;
 cleared = false;
 flagged = false;
 demined = false;
 death = false;
 proximity = -1;
 constructor() {
  Cell.#total++;
  if (Math.random() < Cell.#bias) { this.mine = true; Cell.#mines++; }
  Cell.#bias = ((Cell.#mines/Cell.#total)>Cell.#density) ? Cell.#low : Cell.#high;
 }
 Unmine() { this.mine = false; }
 Step() {
  if ((!this.flagged) & (!this.demined)) {
   this.cleared = true; 
   if (this.mine) this.death = true; 
  }
 }
 Flag() { if (!this.cleared) this.flagged = !this.flagged; }
 Demine() { if (!this.demined & this.flagged) this.demined = true; }
}
class Column {
 cells = [];
 constructor(h) { for (var i=0; i<h; i++) this.insert(); }
 insert(){this.cells.splice(0, 0, new Cell());}
 append(){this.cells.push(new Cell());}
}
class Level {
 static width = 100;
 static height = 100;
 static columns = [];
 static Left(x)  { if (x < 3)              { Level.columns.splice(0, 0, new Column(Level.height));                 Level.width++;  return false; } return true;}
 static Right(x) { if (x > Level.width-3)  { Level.columns.push(new Column(this.height));                          Level.width++;                } return true;}
 static Up(y)    { if (y < 3)              { for (let c=0; c<Level.columns.length; c++) Level.columns[c].insert(); Level.height++; return false; } return true;}
 static Down(y)  { if (y > Level.height-3) { for (let c=0; c<Level.columns.length; c++) Level.columns[c].append(); Level.height++;               } return true;}
 static Step(x,y) {
  if (Level.columns[x].cells[y].proximity == -1) {
   Level.columns[x].cells[y].proximity  = Level.#Mine(x-1,y-1) + Level.#Mine(x  ,y-1) + Level.#Mine(x+1,y-1);
   Level.columns[x].cells[y].proximity += Level.#Mine(x-1,y  ) + Level.#Mine(x  ,y  ) + Level.#Mine(x+1,y  );
   Level.columns[x].cells[y].proximity += Level.#Mine(x-1,y+1) + Level.#Mine(x  ,y+1) + Level.#Mine(x+1,y+1); }
  Level.columns[x].cells[y].Step(); }
 static Flag(x,y) {
  Level.columns[x].cells[y].Flag(); } 
 static #Mine(x,y) { return Level.columns[x].cells[y].mine ? 1 : 0; }
 static { for (var i=0; i<Level.width; i++) Level.columns.push(new Column(Level.height)); }
}
class Side {
 static side = Object.freeze({ left:0, right:1, mouse:2 })
 static #left; 
 static #right;
 static #mouse;
 static #pinching = false;
 #side;
 #e;
 #focussed = false;
 #scrolling = false;
 #point;
 constructor(side) {this.#side = side;}
 #Focus() { Side.#left.#focussed = Side.#right.#focussed = Side.#mouse.#focussed = false; this.#focussed = true; }
 #Is(e) {return (this.#e!=undefined) && (this.#e.pointerId==e.pointerId);}
 #IsDown() {return this.#e!=undefined;}
 static #Pointer(e) {
  if (e.pointerType == 'mouse') return Side.#mouse;
  if (Side.#left.#Is(e)) return Side.#left;
  if (Side.#right.#Is(e)) return Side.#right;
  if (Side.#right.#IsDown()) return Side.#left;
  if (Side.#left.#IsDown()) return Side.#right;
  return (e.offsetX < (window.innerWidth/2)) ? Side.#left : Side.#right;
 } 
 static Down(e) {
  var p = Side.#Pointer(e);
  p.#Focus();
  p.#e = e;
  p.#point = undefined;
  redraw = true;
 }
 #Scrollling() {
  this.#focussed = false;
  return this.#scrolling = this.#scrolling || !(Side.#left.#scrolling || Side.#right.#scrolling || Side.#mouse.#scrolling);
 }
 static #Distance() {if ((Side.#left.#point==undefined)||(Side.#right.#point==undefined)) return 0; else return Math.abs(Side.#right.#point.x - Side.#left.#point.x);}
 static #Zoom(d) {
  var direction = Side.#Distance() - d;
  if (direction < 0) View.Out(); else if (direction > 0) View.In();
  Side.#right.#point=Side.#left.#point=undefined;
 }
 static Move(e) {
  var p = Side.#Pointer(e);
  if (!p.#IsDown()) return;
  var d = Side.#Distance();
  if (p.#point==undefined) p.#point = new Point(e);
  if ((p.#point.x - e.offsetX)>=(0.75*View.size)) {
   p.#point.x-=View.size; 
   if (p.#Scrollling()) 
    Board.IncX(); 
   else 
    Side.#Zoom(d); 
   redraw=true;
   }
  if ((e.offsetX - p.#point.x)>=(0.75*View.size)) {
   p.#point.x+=View.size; 
   if (p.#Scrollling()) 
    Board.DecX(); 
   else 
    Side.#Zoom(d); 
   redraw=true;
  }
  if ((p.#point.y - e.offsetY)>=(0.75*View.size)) {p.#point.y-=View.size; if (p.#Scrollling()) Board.IncY(); redraw=true;}
  if ((e.offsetY - p.#point.y)>=(0.75*View.size)) {p.#point.y+=View.size; if (p.#Scrollling()) Board.DecY(); redraw=true;}
 }
 static Up(e) {
  var p = Side.#Pointer(e);
  if (p.#focussed) {
   if ((p==Side.#right) || ((e.pointerType == 'mouse') && (e.button == 0)))
    Level.Step(Board.x+View.X(e.offsetX), Board.y+View.Y(e.offsetY));
   if ((p==Side.#left) || ((e.pointerType == 'mouse') && (e.button == 2)))
    Level.Flag(Board.x+View.X(e.offsetX), Board.y+View.Y(e.offsetY));
  }
  p.#e = undefined;
  p.#focussed = false;
  p.#scrolling = false;
  redraw = true;
 }
 static {
  Side.#left  = new Side(Side.side.left );
  Side.#right = new Side(Side.side.right);
  Side.#mouse = new Side(Side.side.mouse);
 }
}
class View {
 static left;  static right;
 static top;   static bottom;
 static width; static height;
 static wide;  static high;
 static size;
 static fullScreen = false;
 static #Window() {
  View.width  = View.wide*View.size;
  View.height = View.high*View.size;
  View.left   = Math.floor((window.innerWidth -View.width)/2);
  View.right  = View.left+(View.wide*View.size);
  View.top    = Math.floor((window.innerHeight-View.height)/2);
  View.bottom = View.top+(View.high*View.size);
 }
 static Size() {
  View.size   = Math.floor(window.innerWidth/Math.sqrt(Level.width*(window.innerWidth/window.innerHeight)));
  View.wide   = Math.floor(window.innerWidth /View.size);
  View.high   = Math.floor(window.innerHeight/View.size);
  View.#Window();
 }
 static Resize(e) {
  View.high = Math.floor(window.innerHeight/View.size);
  View.wide = Math.floor(window.innerWidth /View.size);
  View.#Window();
  Board.Resize();
  redraw = true;
 }
 static FullScreen(e) {View.fullScreen = document.fullscreenElement;}
 static #IsFullScreen() {return document.fullscreenElement != undefined;}
 static #GoFullScreen() {Board.canvas.requestFullscreen();}
 static #LeaveFullScreen() {document.exitFullscreen();}
 static In() {
  if (View.#IsFullScreen()) {
   if (View.wide<View.high) {
    if (View.wide > 3) { View.size = Math.floor(window.innerWidth /(--View.wide)); View.high = Math.floor(window.innerHeight/View.size); }
   } else {
    if (View.high > 3) { View.size = Math.floor(window.innerHeight/(--View.high)); View.wide = Math.floor(window.innerWidth /View.size); }
   }
  } else View.#GoFullScreen();
  View.#Window();
 }
 static Out() {
  if (View.#IsFullScreen()) {
   View.#LeaveFullScreen();
  } else {
   if (View.wide<View.high) {
    if (View.wide < 32) { View.size = Math.floor(window.innerWidth /(++View.wide)); View.high = Math.floor(window.innerHeight/View.size); }
   } else {
    if (View.high < 32) { View.size = Math.floor(window.innerHeight/(++View.high)); View.wide = Math.floor(window.innerWidth /View.size); }
   }
  }
  View.#Window();
 }
 static X(x) { return Math.floor((x-View.left)/View.size); }
 static Y(y) { return Math.floor((y-View.top)/View.size); }
}
class Board {
 static x;
 static y;
 static canvas;
 static context;
 static image;
 static Wheel(e) {
  if (e.deltaX != 0) { redraw = true; if (e.deltaX>0) Board.DecX(); else Board.IncX(); }
  if (e.deltaY != 0) { redraw = true; if (e.deltaY<0) Board.DecY(); else Board.IncY(); } }
 static IncX() {if (Level.Right(Board.x+View.wide)) Board.x++;}
 static DecX() {if (Level.Left(Board.x)) Board.x--;}
 static IncY() {if (Level.Down(Board.y+View.high)) Board.y++;}
 static DecY() {if (Level.Up(Board.y)) Board.y--;}
 static Onload() {
  View.Size();
  Board.x = Math.floor((Level.width - View.wide)/2);
  Board.y = Math.floor((Level.height - View.high)/2);
  Board.canvas = document.getElementById('board');
  Board.context = Board.canvas.getContext("2d");
  Board.Resize();
 }
 static Redraw() {
  var X; var Y; var x; var y;
  Board.image.context.fillStyle='#000000';
  Board.image.context.fillRect(0, 0, window.innerWidth, window.innerHeight);
  for (y=Board.y, Y = View.top; Y<View.bottom; y++, Y+=View.size) 
   for (x=Board.x, X = View.left; X<View.right; x++, X+=View.size) 
    Board.image.context.drawImage(Squares.Image(Level.columns[x].cells[y]), 0, 0, Squares.size, Squares.size, X, Y, View.size, View.size);
  Board.context.drawImage(Board.image.canvas, 0, 0, window.innerWidth, window.innerHeight, 0, 0, window.innerWidth, window.innerHeight);
 }
 static Resize() {
  Board.image = new Image(window.innerWidth, window.innerHeight);
  Board.canvas.setAttribute("width", window.innerWidth);
  Board.canvas.setAttribute("height", window.innerHeight);
 }
}
class Control {
 static Onload() {
  window.addEventListener("resize",            function(e) {try {View.Resize(e);                    } catch(x){}});
  window.addEventListener("pointerdown",       function(e) {try {Side.Down(e);   e.preventDefault();} catch(x){}});
  window.addEventListener("pointermove",       function(e) {try {Side.Move(e);   e.preventDefault();} catch(x){}});
  window.addEventListener("pointerup",         function(e) {try {Side.Up(e);     e.preventDefault();} catch(x){}});
  window.addEventListener("wheel",             function(e) {try {Board.Wheel(e);                    } catch(x){}});
  window.addEventListener("toggle-fullscreen", function(e) {try {View.FullScreen(e);                } catch(x){}});
 }
}

var redraw = true;

function twentyfivehertz() {
 if (redraw == true) {
  Board.Redraw();
  redraw = false;
 }
}
function Onload() {
 Board.Onload();
 Control.Onload();
 setInterval(function(){try {twentyfivehertz();} catch(x){}}, 40);
 window.scrollbars.visible = false;
}
window.onload = Onload;
console.log('Sweeper started');
</script><style> canvas{position: absolute; left: 0px; top: 0px;} body{overscroll-behavior-y: none; touch-action: none;} </style></head>
<body><canvas id="board" width="320" height="180" oncontextmenu="return false;"></canvas></body></html>