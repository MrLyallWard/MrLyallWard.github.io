<html><head><title>Sweeper Inifite</title><meta name="copyright" content="Copyright Lyall Ward 2024"><script>
class Point {x; y; constructor(e=undefined) {this.x=(e==undefined)?0:e.offsetX;this.y=(e==undefined)?0:e.offsetY;}}
class Coord {
 x; y;
 constructor(e) {
  this.x=Math.floor((e.offsetX-View.left)/View.size);
  this.y=Math.floor((e.offsetY-View.right)/View.size);}
 Same(e) {return (this.x==e.x) && (this.y==e.y);} }
class Image {
 canvas; context;
 constructor(w, h, c = undefined) {
  this.canvas = (c==undefined)?document.createElement('canvas'):c;
  this.canvas.setAttribute("width", w);
  this.canvas.setAttribute("height", h);
  this.context = this.canvas.getContext("2d"); } }
class Squares {
 static #image = Object.freeze({ 0:0, 1:1, 2:2, 3:3, 4:4, 5:5, 6:6, 7:7, 8:8, mine:9, explosion:10, unknown:11, flag:12, error:13, question:14, danger:15, min:16, max:17, demined:18 })
 static size = 0x200;
 static #step = 0x20;
 static #images = [];
 static #font = [ // 18 characters of a 16 by 16 character font for the board playfield
  [ 0,  0, [ 0xFFFF, 0x8000, 0x8000, 0x8000,  0x8000, 0x8000, 0x8000, 0x8000,  0x8000, 0x8000, 0x8000, 0x8000,  0x8000, 0x8000, 0x8000, 0x8000 ], "#808080"],  // 0
  [ 1,  0, [ 0x0000, 0x0000, 0x0000, 0x00C0,  0x01C0, 0x03C0, 0x07C0, 0x01C0,  0x01C0, 0x01C0, 0x01C0, 0x07F0,  0x07F0, 0x0000, 0x0000, 0x0000 ], "#0000FF"],  // 1
  [ 2,  0, [ 0x0000, 0x0000, 0x0000, 0x0FF0,  0x1FF8, 0x1C38, 0x0038, 0x00F0,  0x03E0, 0x0F80, 0x1E00, 0x1FF8,  0x1FF8, 0x0000, 0x0000, 0x0000 ], "#008000"],  // 2
  [ 3,  0, [ 0x0000, 0x0000, 0x0000, 0x1FF0,  0x1FF8, 0x0038, 0x0038, 0x03F0,  0x03F0, 0x0038, 0x0038, 0x1FF8,  0x1FF0, 0x0000, 0x0000, 0x0000 ], "#FF0000"],  // 3
  [ 4,  0, [ 0x0000, 0x0000, 0x0000, 0x0770,  0x0770, 0x0E70, 0x0E70, 0x1FF8,  0x1FF8, 0x0070, 0x0070, 0x0070,  0x0070, 0x0000, 0x0000, 0x0000 ], "#000080"],  // 4
  [ 5,  0, [ 0x0000, 0x0000, 0x0000, 0x1FF8,  0x1FF8, 0x1C00, 0x1C00, 0x1FF0,  0x1FF8, 0x0038, 0x0038, 0x1FF8,  0x1FF0, 0x0000, 0x0000, 0x0000 ], "#800000"],  // 5
  [ 6,  0, [ 0x0000, 0x0000, 0x0000, 0x0FF0,  0x1FF0, 0x1C00, 0x1C00, 0x1FF0,  0x1FF8, 0x1C38, 0x1C38, 0x1FF8,  0x0FF0, 0x0000, 0x0000, 0x0000 ], "#008080"],  // 6
  [ 7,  0, [ 0x0000, 0x0000, 0x0000, 0x1FF8,  0x1FF8, 0x0078, 0x00F0, 0x01E0,  0x01C0, 0x03C0, 0x0380, 0x0380,  0x0380, 0x0000, 0x0000, 0x0000 ], "#000000"],  // 7
  [ 8,  0, [ 0x0000, 0x0000, 0x0000, 0x0FF0,  0x1FF8, 0x1C38, 0x1C38, 0x0FF0,  0x0FF0, 0x1C38, 0x1C38, 0x1FF8,  0x0FF0, 0x0000, 0x0000, 0x0000 ], "#808080"],  // 8
  [ 9,  0, [ 0x0000, 0x0000, 0x0080, 0x0080,  0x0BE8, 0x07F0, 0x0FF8, 0x0FF8,  0x3FFE, 0x0FF8, 0x0FF8, 0x07F0,  0x0BE8, 0x0080, 0x0080, 0x0000 ], "#000000"],  //mine
  [ 9,  9, [ 0x0000, 0x0000, 0x0000, 0x0000,  0x0000, 0x0000, 0x0300, 0x0300,  0x0000, 0x0000, 0x0000, 0x0000,  0x0000, 0x0000, 0x0000, 0x0000 ], "#FFFFFF"],  //dot
  [10,  9, [ 0x0000, 0x7FFF, 0x7F7F, 0x7F7F,  0x7417, 0x780F, 0x7007, 0x7007,  0x4001, 0x7007, 0x7007, 0x780F,  0x7417, 0x7F7F, 0x7F7F, 0x7FFF ], "#FF0000"],  //explosion
  [11, 11, [ 0xFFFE, 0xFFFC, 0xC000, 0xC000,  0xC000, 0xC000, 0xC000, 0xC000,  0xC000, 0xC000, 0xC000, 0xC000,  0xC000, 0xC000, 0x8000, 0x0000 ], "#FFFFFF"],  //light
  [11, 11, [ 0x0000, 0x0001, 0x0003, 0x0003,  0x0003, 0x0003, 0x0003, 0x0003,  0x0003, 0x0003, 0x0003, 0x0003,  0x0003, 0x0003, 0x3FFF, 0x7FFF ], "#808080"],  //shadow
  [12, 11, [ 0x0000, 0x0000, 0x0000, 0x0180,  0x0780, 0x0F80, 0x0780, 0x0180,  0x0000, 0x0000, 0x0000, 0x0000,  0x0000, 0x0000, 0x0000, 0x0000 ], "#FF0000"],  //flag
  [12, 12, [ 0x0000, 0x0000, 0x0000, 0x0000,  0x0000, 0x0000, 0x0000, 0x0000,  0x0080, 0x0080, 0x03C0, 0x0FF0,  0x0FF0, 0x0000, 0x0000, 0x0000 ], "#000000"],  //post
  [13,  9, [ 0x0000, 0x0000, 0x2002, 0x3006,  0x180C, 0x0C18, 0x0630, 0x0360,  0x01C0, 0x0360, 0x0630, 0x0C18,  0x180C, 0x3006, 0x2002, 0x0000 ], "#FF0000"],  //cross
  [14, 11, [ 0x0000, 0x0000, 0x0000, 0x03C0,  0x0660, 0x0660, 0x0060, 0x00C0,  0x0180, 0x0180, 0x0000, 0x0180,  0x0180, 0x0000, 0x0000, 0x0000 ], "#000000"],  //?
  [15,  0, [ 0x0000, 0x0000, 0x0000, 0x0000,  0x01E0, 0x0330, 0x0330, 0x0030,  0x0060, 0x00C0, 0x00C0, 0x0000,  0x00C0, 0x00C0, 0x0000, 0x0000 ], "#000000"],  //?
  [16, 16, [ 0x3FFF, 0x0001, 0xFFFD, 0x8005,  0x8005, 0x8005, 0x8005, 0x8005,  0x8005, 0x8005, 0x8005, 0x8005,  0x8005, 0x8005, 0x8004, 0xFFFC ], "#FFFFFF"],  //min
  [17, 17, [ 0xFFFF, 0x8001, 0x8001, 0x8001,  0x8001, 0x8001, 0x8001, 0x8001,  0x8001, 0x8001, 0x8001, 0x8001,  0x8001, 0x8001, 0x8001, 0xFFFF ], "#FFFFFF"],  //max
  [18, 11, [ 0x0000, 0x0000, 0x0000, 0x0180,  0x0780, 0x0F80, 0x0780, 0x0180,  0x0000, 0x0000, 0x0000, 0x0000,  0x0000, 0x0000, 0x0000, 0x0000 ], "#FFC000"],  //flag
  [18, 18, [ 0x0000, 0x0000, 0x0000, 0x0000,  0x0000, 0x0000, 0x0000, 0x0000,  0x0080, 0x0080, 0x03C0, 0x0FF0,  0x0FF0, 0x0000, 0x0000, 0x0000 ], "#000000"],  //cleared
 ];
 static #Blank(c) { 
  c.fillStyle='#C0C0C0'; 
  c.fillRect(0,0,Squares.size,Squares.size);
 }
 static #DrawFont(f) {
  var c = Squares.#images[f[0]].context;
  c.drawImage(Squares.#images[f[1]].canvas,0,0);
  c.fillStyle=f[3];
  for (let i = 0; i < f[2].length; i++) {
   var pixels = f[2][i];
   var y = i * Squares.#step;
   for (let x = 0; x <= Squares.size; x += Squares.#step, pixels <<= 1) {if ((pixels & 0x8000) > 0) { c.fillRect(x, y, Squares.#step, Squares.#step); }}}}
 static Image(c) { 
  var i = Squares.#image.unknown;
  if (c.cleared) {
   if (c.proximity >= 0) i = c.proximity;
   if (c.death) i = Squares.#image.explosion;
  } else {
   if (c.flagged) i = Squares.#image.flag;
   if (c.demined) i = Squares.#image.demined; }
  return Squares.#images[i].canvas;
 }
 static Test() {return Squares.#images[0].canvas;}
 static {
  for (let i = 0; i < 19; i++) { Squares.#images.push(new Image(Squares.size, Squares.size)); }
  Squares.#Blank(Squares.#images[0].context);
  Squares.#Blank(Squares.#images[11].context);  
  for (let a = 0; a < Squares.#font.length; a++) { Squares.#DrawFont(Squares.#font[a]); } }
}
class Num {
 static color = Object.freeze({ red:0, green:1, cyan:2, yellow:3 });
 static width = 208;
 static length = 368;
 static #step = 16;
 static #sets = [];
 static x;
 static y;
 static #c = Object.freeze({ 0:0, 1:1, 2:2, 3:3, 4:4, 5:5, 6:6, 7:7, 8:8, 9:9, flag:10, tick:11, man:12, mine:13 });
 static #font = [
  [ 0x000000, 0x1FF7FC, 0x2FE3FA, 0x37C1F6, 0x38000E, 0x38000E, 0x38000E, 0x38000E, 0x38000E, 0x37C1F6, 0x2FE3FA, 0x1FF7FC, 0x000000 ],   // 0
  [ 0x000000, 0x000000, 0x000000, 0x000000, 0x000000, 0x000000, 0x000000, 0x000000, 0x000000, 0x07C1F0, 0x0FE3F8, 0x1FF7FC, 0x000000 ],   // 1
  [ 0x000000, 0x0007FC, 0x200BFA, 0x301DF6, 0x381C0E, 0x381C0E, 0x381C0E, 0x381C0E, 0x381C0E, 0x37DC06, 0x2FE802, 0x1FF000, 0x000000 ],   // 2
  [ 0x000000, 0x000000, 0x200802, 0x301C06, 0x381C0E, 0x381C0E, 0x381C0E, 0x381C0E, 0x381C0E, 0x37DDF6, 0x2FEBFA, 0x1FF7FC, 0x000000 ],   // 3
  [ 0x000000, 0x1FF000, 0x0FE800, 0x07DC00, 0x001C00, 0x001C00, 0x001C00, 0x001C00, 0x001C00, 0x07DDF0, 0x0FEBF8, 0x1FF7FC, 0x000000 ],   // 4
  [ 0x000000, 0x1FF000, 0x2FE802, 0x37DC06, 0x381C0E, 0x381C0E, 0x381C0E, 0x381C0E, 0x381C0E, 0x301DF6, 0x200BFA, 0x0007FC, 0x000000 ],   // 5
  [ 0x000000, 0x1FF7FC, 0x2FEBFA, 0x37DDF6, 0x381C0E, 0x381C0E, 0x381C0E, 0x381C0E, 0x381C0E, 0x301DF6, 0x200BFA, 0x0007FC, 0x000000 ],   // 6
  [ 0x000000, 0x000000, 0x200000, 0x300000, 0x380000, 0x380000, 0x380000, 0x380000, 0x380000, 0x37C1F0, 0x2FE3F8, 0x1FF7FC, 0x000000 ],   // 7
  [ 0x000000, 0x1FF7FC, 0x2FEBFA, 0x37DDF6, 0x381C0E, 0x381C0E, 0x381C0E, 0x381C0E, 0x381C0E, 0x37DDF6, 0x2FEBFA, 0x1FF7FC, 0x000000 ],   // 8
  [ 0x000000, 0x1FF000, 0x2FE802, 0x37DC06, 0x381C0E, 0x381C0E, 0x381C0E, 0x381C0E, 0x381C0E, 0x37DDF6, 0x2FEBFA, 0x1FF7FC, 0x000000 ],   // 9
  [ 0x000000, 0x000000, 0x000000, 0x0080C0, 0x01C0C0, 0x01C1C0, 0x03E1C0, 0x03FFC0, 0x0001C0, 0x0000C0, 0x0000C0, 0x000000, 0x000000 ],   // flag
  [ 0x000060, 0x000070, 0x000038, 0x00001C, 0x00000E, 0x00001E, 0x0000FC, 0x0007E0, 0x003F00, 0x01F800, 0x0FC000, 0x7E0000, 0x700000 ],   // tick
  [ 0x000000, 0x00FF00, 0x01FF00, 0x01C000, 0x1DFFFE, 0x3FFFFE, 0x3FFF00, 0x3FFFFE, 0x1DFFFE, 0x01C000, 0x01FF00, 0x00FF00, 0x000000 ],   // man
  [ 0x03FFE0, 0x03F7E0, 0x034160, 0x0380E0, 0x033060, 0x033060, 0x020020, 0x030060, 0x030060, 0x0380E0, 0x034160, 0x03F7E0, 0x03FFE0 ], ];// mine
 static #colors = [
  [ "#FF0000FF", "#40000080", "#00000080", Num.#c.flag ], [ "#00FF00FF", "#00400080", "#00000080", Num.#c.man  ],
  [ "#00F0F0FF", "#10404080", "#00000080", Num.#c.tick ], [ "#FFFF00FF", "#40400080", "#00000080", Num.#c.mine ] ];
 static #DrawPixels(c, p, f, b=undefined) {
  for (let i = 0; i < p.length; i++) {
   var x = i*Num.#step;
   var pixels = p[i];
   for (let y = 0; y < Num.length; y += Num.#step, pixels <<= 1) {
    var s = ((pixels & 0x400000) > 0) ? f : b;
    c.fillStyle = s;
    if (s != undefined) c.fillRect(x, y, Num.#step, Num.#step); 
   }
  }
 }
 static {
  for (let i=0;i<Num.#colors.length;i++) {
   var set = [];
   var col = Num.#colors[i];
   for (let j=0;j<12;j++) set.push(new Image(Num.width, Num.length));
   Num.#DrawPixels(set[10].context, Num.#font[     8], col[1], col[2]);
   Num.#DrawPixels(set[11].context, Num.#font[col[3]], col[0], col[2]);
   for (let k=0;k<10;k++) {
    set[k].context.drawImage(set[10].canvas, 0, 0);
    Num.#DrawPixels(set[k].context, Num.#font[k], col[0]); }
   Num.#sets.push(set); } } 
 static Show(c,n) {
  var set=Num.#sets[c];
  var s=[];
  for (let i=0; i<6; i++) {
   var d = n%10;
   n = (n-d)/10;
   s.splice(0,0,((d==0)&&(n==0))?set[10]:set[d]);
  }
  s.push(set[11]);
  Num.x = Math.floor(View.width/24);
  Num.y = (Num.x*Num.length)/Num.width;
  switch(c) {
   case Num.color.red    : Board.DrawRight(View.left,View.top,s); break;
   case Num.color.green  : Board.DrawLeft(View.right,View.top,s); break;
   case Num.color.cyan   : Board.DrawRight(View.left,View.bottom-Num.y,s); break;
   case Num.color.yellow : Board.DrawLeft(View.right,View.bottom-Num.y,s); break;
  }
 }
}
class Score {
 static steps = 0;
 static lives = 3;
 static steps;
 static mines;
 static Step(s) {Score.steps += s;}
 static Death(cell) {if (cell.mine) {cell.death = true; if (Score.lives > 0) Score.lives--;} return cell.death;}
 static RestartCounters() {Score.flags = 0; Score.mines = 0;}
}
class Cell {
 static #high = 0.26;
 static #density = 0.25;
 static #low = 0.24;
 static #bias = Cell.#density;
 static #mines = 0;
 static #total = 0;
 mine = false;
 cleared = false;
 flagged = false;
 demined = false;
 death = false;
 solving = false;
 proximity = -1;
 constructor() {
  Cell.#total++;
  if (Math.random() < Cell.#bias) { this.mine = true; Cell.#mines++; }
  Cell.#bias = ((Cell.#mines/Cell.#total)>Cell.#density) ? Cell.#low : Cell.#high;
 }
 Unmine() { this.mine = false; }
 Step() { if ((!this.flagged) & (!this.demined) & (!this.cleared)) { this.cleared = true; if (!Score.Death(this)) return 1; } return 0; }
 Flag() { if (!this.cleared) this.flagged = !this.flagged; }
 Demine() { if (!this.demined & this.flagged) this.demined = true; }
}
class Column {
 cells = [];
 constructor(h) { for (var i=0; i<h; i++) this.insert(); }
 insert(){this.cells.splice(0, 0, new Cell());}
 append(){this.cells.push(new Cell());}
}
class Level {
 static width = 256;
 static height = 256;
 static #columns = [];
 static Left(x)  {if (x < 3)              {Level.#columns.splice(0, 0, new Column(Level.height));                  Level.width++;  return false;} return true;}
 static Right(x) {if (x > Level.width-3)  {Level.#columns.push(new Column(this.height));                           Level.width++;               } return true;}
 static Up(y)    {if (y < 3)              {for (let c=0; c<Level.#columns.length; c++) Level.#columns[c].insert(); Level.height++; return false;} return true;}
 static Down(y)  {if (y > Level.height-3) {for (let c=0; c<Level.#columns.length; c++) Level.#columns[c].append(); Level.height++;              } return true;}
 static Step(x,y) {
  if (Level.#columns[x].cells[y].proximity == -1) {
   Level.#columns[x].cells[y].proximity  = Level.#Mine(x-1,y-1) + Level.#Mine(x,y-1) + Level.#Mine(x+1,y-1);
   Level.#columns[x].cells[y].proximity += Level.#Mine(x-1,y  ) + Level.#Mine(x,y  ) + Level.#Mine(x+1,y  );
   Level.#columns[x].cells[y].proximity += Level.#Mine(x-1,y+1) + Level.#Mine(x,y+1) + Level.#Mine(x+1,y+1);
   Level.#columns[x].cells[y].solving = Level.#columns[x].cells[y].proximity == 0; }
  Level.#columns[x].cells[y].Step(); }
 static Flag(x,y) { Level.#columns[x].cells[y].Flag(); }
 static Cell(x,y) {
  var c = Level.#columns[x].cells[y];
  Level.#Clearing(c,x,y);
  Side.Boundaries(c,x,y);
  return c; }
 static #Clearing(c,x,y) {
  if (c.solving) {
   Level.Step(x-1,y-1); Level.Step(x,y-1); Level.Step(x+1,y-1); Level.Step(x-1,y); Level.Step(x+1,y); Level.Step(x-1,y+1); Level.Step(x,y+1); Level.Step(x+1,y+1);
   c.solving = false; clearing = true; } }
 static #Mine(x,y) { return Level.#columns[x].cells[y].mine ? 1 : 0; }
 static #FirstCells() {for (var i=0; i<Level.width; i++) Level.#columns.push(new Column(Level.height));}
 static #FirstStep() {
  for (let x = (Level.width-6)/2; x < (Level.width+6)/2; x++) for (let y = (Level.height-6)/2; y < (Level.height+6)/2; y++) Level.#columns[x].cells[y].mine = false;
  Level.#columns[Level.width/2].cells[Level.height/2].cleared = true;
  Level.Step(Level.width/2, Level.height/2); }
 static { Level.#FirstCells(); Level.#FirstStep(); } }
class Cursor {
 static states = Object.freeze({ focussed:0, scrolling:1, nothing:2 })
 //static styles = Object.freeze({ none:0, left:1, right:2, flag:3, mine:4 })
 static cursors = [];
 point;
 style;
 state = Cursor.states.nothing;;
 constructor(s) {this.style=s; this.point = new Point(); Cursor.cursors.push(this);}
 static #sides = [        // focussed                                                 // scrolling  
  [[[0/8, "#00FF0080"],[2/8, "#00FF0080"],[5/8, "#00FF0000"]], [[4/8, "#FF000000"],[5/8, "#FF000070"],[7/8, "#FF000070"],[8/8, "#FF000000"]],[]], //left
  [[[0/8, "#FF000080"],[2/8, "#FF000080"],[5/8, "#FF000000"]], [[4/8, "#00FF0000"],[5/8, "#00FF0070"],[7/8, "#00FF0070"],[8/8, "#00FF0000"]],[]], //right
  [[],[],[]]];                                                                                                                                    //mouse
//[0/8, "#0030FF80"],[2/8, "#0040FF80"],[5/8, "#0040FF00"]], [[4/8, "#0040FF00"],[5/8, "#0040FF40"],[7/8, "#0040FF40"],[8/8, "#0040FF00"]],[]]];//mouse
 static #Draw(c, a) {
  if (a.length>0) {
   var g = c.createRadialGradient(s.point.x, s.point.y, 0, s.point.x, s.point.y, Math.min(window.innerWidth, window.innerHeight) / 4);
   for (var i=0; i<a.length; i++) g.addColorStop(a[i][0], a[i][1]);
   c.fillStyle = g;
   c.fillRect(0, 0, window.innerWidth, window.innerHeight); } }
 static Draw(c) { for (var i=0; i<Cursor.cursors.length;i++) Cursor.#Draw(c, Cursor.#sides[Cursor.cursors[i].style][Cursor.cursors[i].state]); }
 Update(e)   {this.point.x = e.offsetX; this.point.y = e.offsetY;}
 Focus()     {this.state = Cursor.states.focussed;}
 Scroll()    {this.state = Cursor.states.scrolling;}
 Release()   {this.state = Cursor.states.nothing;}
 Focussed()  {return this.state == Cursor.states.focussed;}
 Scrolling() {return this.state == Cursor.states.scrolling;}
}
class Side {
 static side = Object.freeze({ left:0, right:1, mouse:2 })
 static #left; 
 static #right;
 static #mouse;
 static canUp;
 static canDown;
 static canLeft;
 static canRight;
 #side;
 #e;
 #point;
 #cursor;
 constructor(side, cursor=undefined) {this.#side = side; this.#cursor = cursor;}
 #Is(e) {return (this.#e!=undefined) && (this.#e.pointerId==e.pointerId);}
 #IsDown() {return this.#e!=undefined;}
 #Focus() {
  if ((Side.#left == this) && Side.#right.#cursor.Focussed()) Side.#right.#cursor.Scroll();
  if ((Side.#right == this) && Side.#left.#cursor.Focussed()) Side.#left.#cursor.Scroll();
  this.#cursor.Focus(); 
  }
 #Scrolling() {
  var s = this.#cursor.Scrolling() || !(Side.#left.#cursor.Scrolling() || Side.#right.#cursor.Scrolling() || Side.#mouse.#cursor.Scrolling())
  if (s) this.#cursor.Scroll();
  return s;
 }
 static #Pointer(e) {
  if (e.pointerType == 'mouse') return Side.#mouse;
  if (Side.#left.#Is(e)) return Side.#left;
  if (Side.#right.#Is(e)) return Side.#right;
  if (Side.#right.#IsDown()) return Side.#left;
  if (Side.#left.#IsDown()) return Side.#right;
  return (e.offsetX < (window.innerWidth/2)) ? Side.#left : Side.#right;
 }
 static #Distance() {if ((Side.#left.#point==undefined)||(Side.#right.#point==undefined)) return 0; else return Math.abs(Side.#right.#point.x - Side.#left.#point.x);}
 static #Zoom(d) {
  var direction = Side.#Distance() - d;
  if (direction < 0) View.Out(); else if (direction > 0) View.In();
  Side.#right.#point=Side.#left.#point=undefined;
 }
 static RestartBoundaries() { Side.canUp = Side.canDown = Side.canLeft = Side.canRight = false; }
 static Boundaries(c,x,y) {
  if (c.cleared) {
   Side.canUp    |= (y==Board.y);
   Side.canDown  |= (y==(Board.y+View.high-1));
   Side.canLeft  |= (x==Board.x);
   Side.canRight |= (x==(Board.x+View.wide-1));
  }
 }
 static Down(e) {
  var p = Side.#Pointer(e);
  p.#cursor.Update(e);
  p.#Focus();
  p.#e = e;
  p.#point = new Point(e);
  redraw = true;
 }
 static Move(e) {
  var p = Side.#Pointer(e);
  p.#cursor.Update(e);
  redraw=true;
  if (!p.#IsDown()) return;
  var d = Side.#Distance();
  if (p.#point==undefined) p.#point = new Point(e);
  if ((p.#point.x - e.offsetX)>=(0.75*View.size)) {p.#point.x-=View.size; if (p.#Scrolling() && Side.canRight) Board.IncX(); else Side.#Zoom(d); }
  if ((e.offsetX - p.#point.x)>=(0.75*View.size)) {p.#point.x+=View.size; if (p.#Scrolling() && Side.canLeft ) Board.DecX(); else Side.#Zoom(d); }
  if ((p.#point.y - e.offsetY)>=(0.75*View.size)) {p.#point.y-=View.size; if (p.#Scrolling() && Side.canDown ) Board.IncY();                     }
  if ((e.offsetY - p.#point.y)>=(0.75*View.size)) {p.#point.y+=View.size; if (p.#Scrolling() && Side.canUp   ) Board.DecY();                     }
 }
 static Up(e) {
  var p = Side.#Pointer(e);
  if (p.#cursor.Focussed()) {
   if ((p==Side.#right) || ((e.pointerType == 'mouse') && (e.button == 0)))
    Score.Step(Level.Step(Board.x+View.X(e.offsetX), Board.y+View.Y(e.offsetY)));
   if ((p==Side.#left) || ((e.pointerType == 'mouse') && (e.button == 2)))
    Level.Flag(Board.x+View.X(e.offsetX), Board.y+View.Y(e.offsetY));
  }
  p.#cursor.Release();
  p.#e = undefined;
  redraw = true;
 }
 static {
  Side.#left  = new Side(Side.side.left,  new Cursor(Side.side.left));
  Side.#right = new Side(Side.side.right, new Cursor(Side.side.right));
  Side.#mouse = new Side(Side.side.mouse, new Cursor(Side.side.mouse));
 }
}
class View {
 static left;  static right;
 static top;   static bottom;
 static width; static height;
 static wide;  static high;
 static size;
 static fullScreen = false;
 static #Window() {
  View.width  = View.wide*View.size;
  View.height = View.high*View.size;
  View.left   = Math.floor((window.innerWidth -View.width)/2);
  View.right  = View.left+(View.wide*View.size);
  View.top    = Math.floor((window.innerHeight-View.height)/2);
  View.bottom = View.top+(View.high*View.size);
 }
 static Size() {
  View.size   = Math.floor(window.innerWidth/Math.sqrt(Level.width*(window.innerWidth/window.innerHeight)));
  View.wide   = Math.floor(window.innerWidth /View.size);
  View.high   = Math.floor(window.innerHeight/View.size);
  View.#Window();
 }
 static Resize(e) {
  View.high = Math.floor(window.innerHeight/View.size);
  View.wide = Math.floor(window.innerWidth /View.size);
  View.#Window();
  Board.Resize();
  redraw = true;
 }
 static FullScreen(e) {View.fullScreen = document.fullscreenElement;}
 static #IsFullScreen() {return document.fullscreenElement != undefined;}
 static #GoFullScreen() {Board.canvas.requestFullscreen();}
 static #LeaveFullScreen() {document.exitFullscreen();}
 static In() {
  if (View.#IsFullScreen()) {
   if (View.wide<View.high) {
    if (View.wide > 3) { View.size = Math.floor(window.innerWidth /(--View.wide)); View.high = Math.floor(window.innerHeight/View.size); }
   } else {
    if (View.high > 3) { View.size = Math.floor(window.innerHeight/(--View.high)); View.wide = Math.floor(window.innerWidth /View.size); }
   }
  } else View.#GoFullScreen();
  View.#Window();
 }
 static Out() {
  if (View.#IsFullScreen()) {
   View.#LeaveFullScreen();
  } else {
   if (View.wide<View.high) {
    if (View.wide < 32) { View.size = Math.floor(window.innerWidth /(++View.wide)); View.high = Math.floor(window.innerHeight/View.size); }
   } else {
    if (View.high < 32) { View.size = Math.floor(window.innerHeight/(++View.high)); View.wide = Math.floor(window.innerWidth /View.size); }
   }
  }
  View.#Window();
 }
 static X(x) { return Math.floor((x-View.left)/View.size); }
 static Y(y) { return Math.floor((y-View.top)/View.size); }
}
class Board {
 static x;
 static y;
 static canvas;
 static context;
 static image;
 static Wheel(e) {
  if (e.deltaX != 0) { redraw = true; if (e.deltaX>0) {if (Side.canLeft) Board.DecX();} else {if (Side.canRight) Board.IncX();} }
  if (e.deltaY != 0) { redraw = true; if (e.deltaY<0) {if (Side.canUp  ) Board.DecY();} else {if (Side.canDown ) Board.IncY();} } }
 static IncX() {if (Level.Right(Board.x+View.wide)) Board.x++;}
 static DecX() {if (Level.Left(Board.x)) Board.x--;}
 static IncY() {if (Level.Down(Board.y+View.high)) Board.y++;}
 static DecY() {if (Level.Up(Board.y)) Board.y--;}
 static Onload() {
  View.Size();
  Board.x = Math.floor((Level.width - View.wide)/2);
  Board.y = Math.floor((Level.height - View.high)/2);
  Board.canvas = document.getElementById('board');
  Board.context = Board.canvas.getContext("2d");
  Board.Resize();
 }
 static Redraw() {
  var X; var Y;
  Score.RestartCounters();
  Side.RestartBoundaries();
  Board.image.context.fillStyle='#000000';
  Board.image.context.fillRect(0, 0, window.innerWidth, window.innerHeight);
  for (let y=Board.y, Y = View.top; Y<View.bottom; y++, Y+=View.size) 
   for (let x=Board.x, X = View.left; X<View.right; x++, X+=View.size) 
    Board.image.context.drawImage(Squares.Image(Level.Cell(x, y)), 0, 0, Squares.size, Squares.size, X, Y, View.size, View.size);
  Num.Show(Num.color.red, 1234);
  Num.Show(Num.color.green, 6789);
  Num.Show(Num.color.cyan, 9876);
  Num.Show(Num.color.yellow, 54321);
  Cursor.Draw(Board.image.context);
  Board.context.drawImage(Board.image.canvas, 0, 0, window.innerWidth, window.innerHeight, 0, 0, window.innerWidth, window.innerHeight);
 }
 static DrawRight(x,y,images) {
  for (var i=0; i<images.length; x+=Num.x)
   Board.image.context.drawImage(images[i++].canvas, 0, 0, Num.width, Num.length, x, y, Num.x, Num.y);
 }
 static DrawLeft(x,y,images) {
  for (var i=images.length; i>0;)
   Board.image.context.drawImage(images[--i].canvas, 0, 0, Num.width, Num.length, x-=Num.x, y, Num.x, Num.y);
 }
 static Resize() {
  Board.image = new Image(window.innerWidth, window.innerHeight);
  Board.canvas.setAttribute("width", window.innerWidth);
  Board.canvas.setAttribute("height", window.innerHeight);
 }
}
class Control {
 static Onload() {
  window.addEventListener("resize",            function(e) {try {View.Resize(e);                    } catch(x){}});
  window.addEventListener("pointerdown",       function(e) {try {Side.Down(e);   e.preventDefault();} catch(x){}});
  window.addEventListener("pointermove",       function(e) {try {Side.Move(e);   e.preventDefault();} catch(x){}});
  window.addEventListener("pointerup",         function(e) {try {Side.Up(e);     e.preventDefault();} catch(x){}});
  window.addEventListener("wheel",             function(e) {try {Board.Wheel(e);                    } catch(x){}});
  window.addEventListener("toggle-fullscreen", function(e) {try {View.FullScreen(e);                } catch(x){}});
 }
}

var redraw = true;
var clearing = false;

function twentyfivehertz() {
 if (redraw || clearing) {
  Board.Redraw();
  redraw = clearing;
  clearing = false;
 }
}
function Onload() {
 Board.Onload();
 Control.Onload();
 setInterval(function(){try {twentyfivehertz();} catch(x){}}, 40);
 window.scrollbars.visible = false;
}
window.onload = Onload;
console.log('Sweeper started');
</script><style> canvas{position: absolute; left: 0px; top: 0px;} body{overscroll-behavior-y: none; touch-action: none;} </style></head>
<body><canvas id="board" width="320" height="180" oncontextmenu="return false;"></canvas></body></html>